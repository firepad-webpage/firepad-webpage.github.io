<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excerpt</title>
</head>
<body>
    <h2>Excerpt</h2>
    <p>Memory safety bugs continue to be a major source of security vulnerabilities, despite much research on software bug-finding and mitigation approaches.</p><p>The CHERI project, developed by the University of Cambridge and SRI International since 2010, offers a promising hardware-based approach.</p><p>CHERI extends conventional hardware Instruction-Set Architectures (ISAs) to enable support for fine-grained memory protection and for scalable software compartmentalisation, with hardware-supported capabilities.</p><p>The ISA design ensures that capabilities cannot be forged, i.e., that normal code execution can shrink capabilities but never grow them.</p><p>The CHERI architectural mechanisms can be used by language implementations and systems software in various ways to provide improved security.</p><p>A 2019 analysis suggested that 30â€“70% of the vulnerabilities reported to the Microsoft Security Response Center (MSRC) would have been deterministically mitigated by CHERI memory-safety.</p><p>All this raises the question that we address in this paper: what is CHERI C, exactly?</p><p>We make the following contributions: discussion of the design issues that arise in the design of CHERI C and its semantics, including the subtle interactions between capabilities, undefined behaviour, and pointer provenance.</p><p>An executable mechanised semantics of CHERI C, reifying the above as an extension of the Cerberus ISO C semantics.</p><p>The CHERI C memory object model is mechanised within Coq, with the extracted code used in the executable semantics.</p><p>A prose definition of CHERI C.</p><p>Validation and experimental comparison.</p><p>CHERI-enabled architectures add new hardware support for capabilities in registers and in memory.</p><p>A capability includes an address together with bounds, permissions, and other metadata.</p><p>The one-bit tag provides integrity protection: it is preserved only by legitimate operations on capabilities and cleared by any others.</p><p>A capability can only be used as such, e.g., for a dereference, if its tag is set.</p><p>The permission bits control whether a capability can be used for loading or storing data or fetching instructions.</p><p>ISO C relies crucially on the notion of undefined behaviour (UB), to make it possible to define the semantics of a memory-unsafe language.</p><p>Any program for which there exists an abstract machine execution which has undefined behaviour is deemed to have undefined behaviour as a whole.</p><p>In CHERI C, source-language pointers are represented with hardware capabilities.</p><p>The compiler introduces code to construct a capability with correctly narrowed bounds derived from the stack-pointer capability.</p><p>The design of CHERI C has to reconcile three major and at times conflicting objectives: porting existing codebases, maintaining performance, and deterministically mitigating memory-safety errors.</p><p>CHERI C needs a well-defined and comprehensible semantics for all involved.</p><p>We give what we call the positive semantics, to clearly define what programmers can rely on, and what they are obliged to ensure, for well-defined CHERI C code.</p><p>CHERI C clearly deterministically mitigates many otherwise-exploitable security flaws, but undefined behaviour and compiler optimisations make it unclear what precise security properties it provides in general.</p><p>We choose to follow the stricter ISO rule also for CHERI C, even though that leaves code that exploits the architectural guarantee as UB.</p><p>We allow (u)intptr_t arithmetic within some region of representability, but keep defined behaviour and the integer (address-part) value of the result defined if one goes outside.</p><p>We permit casts to pointer types of (u)intptr_t capabilities with this bit set, and loads and stores of them, but make it UB to access memory via them.</p><p>Our current proposed solution is for the abstract CHERI C machine to record any non-capability write to a capability using ghost state.</p><p>Pointer values are capabilities, and tag, bounds, and permission checks are performed when they are used to access memory.</p><p>Pointer equality in CHERI C compares just the address fields, not the full capability metadata.</p><p>For binary arithmetic operations on two values of capability-carrying types, the resulting capabilities are derived from their left arguments.</p><p>Based on experience in porting code, the current default behaviour of CHERI C is to not enforce subobject bounds.</p><p>Objects created at const-qualified types are expected to be immutable, so in CHERI C those casts are no-ops on the underlying capability.</p><p>The C semantics needs a common abstraction of hardware capabilities.</p><p>We restrict the abstract scope of compression to four capability fields: address, flags, and upper and lower bounds.</p><p>The capability checks at runtime could not subsume provenance checks at compile time.</p><p>The two are complementary.</p><p>We codified CHERI C semantics as an extension of Cerberus, a well-validated semantic model for ISO C.</p><p>We defined the CHERI C memory object model in Coq and extracted it to OCaml to integrate into Cerberus.</p><p>CHERI C adds the following new undefined behaviours: UB_CHERI_InvalidCap (dereference with tag cleared), UB_CHERI_UndefinedTag (tag marked unspecified), UB_CHERI_InsufficientPermissions (lacking permission bit), UB_CHERI_BoundsViolation (out-of-bounds access), and UB012_lvalue_read_trap_representation (decode failure).</p><p>We validate our semantics by discussion with CHERI C implementers and porters of large codebases.</p><p>We validate experimentally using a test suite of 94 tests across semantic categories.</p><p>We compiled and ran all our tests using three CHERI C implementations and compared the results.</p><p>Cerberus passes all our tests with the results we expect, modulo one known bug.</p><p>The Clang/LLVM compiler is mostly compliant with our CHERI C semantics definition.</p><p>CHERI GCC is a relatively new arrival; our test suite identified five issues, one of which was confirmed as a bug.</p><p>CHERIoT targets embedded systems and could not be directly tested, but CHERI C semantics are applicable to it.</p><p>Our mechanised semantics for CHERI C should provide clarity of what is (and is not) guaranteed by the language.</p><p>The semantics would provide a solid basis for program analysis or model-checking of CHERI C.</p>
    <h2>Original Abstract</h2> 
    <p>CHERI (Capability Hardware Enhanced RISC Instructions) is a hardware-software co-design developed to address persistent memory safety vulnerabilities in C-based systems. By extending conventional ISAs with unforgeable capabilities, CHERI enables fine-grained memory protection and scalable compartmentalization. This paper investigates the formal semantics of CHERI C, the dialect of C used to program CHERI-enabled systems. The authors identify key design tensions between supporting legacy codebases, preserving performance, and enforcing deterministic mitigation of memory safety errors. They present a rigorous, mechanised semantics for CHERI C as an extension of the Cerberus ISO C model, including a Coq-verified memory object model and an executable OCaml semantics. The semantics captures nuanced interactions involving capabilities, undefined behavior, and pointer provenance. Validation includes collaboration with CHERI implementers, experimental testing on 94 semantic scenarios across multiple CHERI C compilers, and identification of conformance gaps. The resulting semantics defines new forms of undefined behavior unique to CHERI C and clarifies guarantees offered by capability-based memory safety. This work provides a foundational tool for reasoning about, verifying, and analyzing CHERI C programs, contributing to more secure systems software.</p>
</body>
</html>
