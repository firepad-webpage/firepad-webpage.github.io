<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excerpt</title>
</head>
<body>
    <h2>Excerpt</h2>
    <p>Memory safety bugs continue to be a major source of security vulnerabilities, despite much research on software bug-finding and mitigation approaches.</p><p>The CHERI project, developed by the University of Cambridge and SRI International since 2010, offers a promising hardware-based approach.</p><p>CHERI extends conventional hardware Instruction-Set Architectures (ISAs) to enable support for fine-grained memory protection and for scalable software compartmentalisation, with hardware-supported capabilities.</p><p>The ISA design ensures that capabilities cannot be forged, i.e., that normal code execution can shrink capabilities but never grow them.</p><p>The CHERI architectural mechanisms can be used by language implementations and systems software in various ways to provide improved security.</p><p>A 2019 analysis suggested that 30–70% of the vulnerabilities reported to the Microsoft Security Response Center (MSRC) would have been deterministically mitigated by CHERI memory-safety.</p><p>All this raises the question that we address in this paper: what is CHERI C, exactly?</p><p>We make the following contributions: discussion of the design issues that arise in the design of CHERI C and its semantics, including the subtle interactions between capabilities, undefined behaviour, and pointer provenance.</p><p>An executable mechanised semantics of CHERI C, reifying the above as an extension of the Cerberus ISO C semantics.</p><p>The CHERI C memory object model is mechanised within Coq, with the extracted code used in the executable semantics.</p><p>A prose definition of CHERI C.</p><p>Validation and experimental comparison.</p><p>CHERI-enabled architectures add new hardware support for capabilities in registers and in memory.</p><p>A capability includes an address together with bounds, permissions, and other metadata.</p><p>The one-bit tag provides integrity protection: it is preserved only by legitimate operations on capabilities and cleared by any others.</p><p>A capability can only be used as such, e.g., for a dereference, if its tag is set.</p><p>The permission bits control whether a capability can be used for loading or storing data or fetching instructions.</p><p>ISO C relies crucially on the notion of undefined behaviour (UB), to make it possible to define the semantics of a memory-unsafe language.</p><p>Any program for which there exists an abstract machine execution which has undefined behaviour is deemed to have undefined behaviour as a whole.</p><p>In CHERI C, source-language pointers are represented with hardware capabilities.</p><p>The compiler introduces code to construct a capability with correctly narrowed bounds derived from the stack-pointer capability.</p><p>The design of CHERI C has to reconcile three major and at times conflicting objectives: porting existing codebases, maintaining performance, and deterministically mitigating memory-safety errors.</p><p>CHERI C needs a well-defined and comprehensible semantics for all involved.</p><p>We give what we call the positive semantics, to clearly define what programmers can rely on, and what they are obliged to ensure, for well-defined CHERI C code.</p><p>CHERI C clearly deterministically mitigates many otherwise-exploitable security flaws, but undefined behaviour and compiler optimisations make it unclear what precise security properties it provides in general.</p><p>We choose to follow the stricter ISO rule also for CHERI C, even though that leaves code that exploits the architectural guarantee as UB.</p><p>We allow (u)intptr_t arithmetic within some region of representability, but keep defined behaviour and the integer (address-part) value of the result defined if one goes outside.</p><p>We permit casts to pointer types of (u)intptr_t capabilities with this bit set, and loads and stores of them, but make it UB to access memory via them.</p><p>Our current proposed solution is for the abstract CHERI C machine to record any non-capability write to a capability using ghost state.</p><p>Pointer values are capabilities, and tag, bounds, and permission checks are performed when they are used to access memory.</p><p>Pointer equality in CHERI C compares just the address fields, not the full capability metadata.</p><p>For binary arithmetic operations on two values of capability-carrying types, the resulting capabilities are derived from their left arguments.</p><p>Based on experience in porting code, the current default behaviour of CHERI C is to not enforce subobject bounds.</p><p>Objects created at const-qualified types are expected to be immutable, so in CHERI C those casts are no-ops on the underlying capability.</p><p>The C semantics needs a common abstraction of hardware capabilities.</p><p>We restrict the abstract scope of compression to four capability fields: address, flags, and upper and lower bounds.</p><p>The capability checks at runtime could not subsume provenance checks at compile time.</p><p>The two are complementary.</p><p>We codified CHERI C semantics as an extension of Cerberus, a well-validated semantic model for ISO C.</p><p>We defined the CHERI C memory object model in Coq and extracted it to OCaml to integrate into Cerberus.</p><p>CHERI C adds the following new undefined behaviours: UB_CHERI_InvalidCap (dereference with tag cleared), UB_CHERI_UndefinedTag (tag marked unspecified), UB_CHERI_InsufficientPermissions (lacking permission bit), UB_CHERI_BoundsViolation (out-of-bounds access), and UB012_lvalue_read_trap_representation (decode failure).</p><p>We validate our semantics by discussion with CHERI C implementers and porters of large codebases.</p><p>We validate experimentally using a test suite of 94 tests across semantic categories.</p><p>We compiled and ran all our tests using three CHERI C implementations and compared the results.</p><p>Cerberus passes all our tests with the results we expect, modulo one known bug.</p><p>The Clang/LLVM compiler is mostly compliant with our CHERI C semantics definition.</p><p>CHERI GCC is a relatively new arrival; our test suite identified five issues, one of which was confirmed as a bug.</p><p>CHERIoT targets embedded systems and could not be directly tested, but CHERI C semantics are applicable to it.</p><p>Our mechanised semantics for CHERI C should provide clarity of what is (and is not) guaranteed by the language.</p><p>The semantics would provide a solid basis for program analysis or model-checking of CHERI C.</p>
    <h2>Original Abstract</h2> 
    <p>Memory safety issues are a persistent source of security vulnerabilities, with conventional architectures and the C codebase chronically prone to exploitable errors. The CHERI research project has shown how one can provide radically improved security for that existing codebase with minimal modification, using unforgeable hardware capabilities in place of machine-word pointers in CHERI dialects of C, implemented as adaptions of Clang/LLVM and GCC. CHERI was first prototyped as extensions of MIPS and RISC-V; it is currently being evaluated by Arm and others with the Arm Morello experimental architecture, processor, and platform, to explore its potential for mass-market adoption, and by Microsoft in their CHERIoT design for embedded cores.</p><p>There is thus considerable practical experience with CHERI C implementation and use, but exactly what CHERI C’s semantics is (or should be) remains an open question. In this paper, we present the first attempt to rigorously and comprehensively define CHERI C semantics, discuss key semantics design questions relating to capabilities, provenance, and undefined behaviour, and clarify them with semantics in multiple complementary forms: in prose, as an executable semantics adapting the Cerberus C semantics, and mechanised in Coq.</p><p>This establishes a solid foundation for CHERI C, for those porting code to it, for compiler implementers, and for future semantics and verification.</p>
</body>
</html>
