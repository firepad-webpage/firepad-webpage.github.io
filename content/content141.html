<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excerpt</title>
</head>
<body>
    <h2>Excerpt</h2>
    <p>Historically, approaches to Information Extraction (IE) have been divided into two paradigms: rule-based IE, such as IBM’s SystemT, and ML-based IE of which Transformers and LLMs are the predominant example.</p><p>While the latter have shown impressive capabilities, it is increasingly recognized that to reach acceptable accuracy in practical scenarios one has to orchestrate LLM-based extractors using scenario-specific logic.</p><p>This logic is often implemented imperatively in languages such as Python.</p><p>In this paper, we present SpannerLib, a rule-based approach to IE that facilitates the orchestration of ML-based IE in a declarative framework.</p><p>Document spanners have been studied over the past decade as the theoretical core of industrial systems for Information Extraction (IE) from text such as IBM’s SystemT.</p><p>The framework casts IE as relational querying: generic IE functions (such as regular expressions with capture variables) extract base relations that, in turn, are manipulated by the relational algebra.</p><p>Thus, the framework allows to utilize the simplicity and popularity of query languages, such as SQL, to greatly simplify the development of solutions for text analysis.</p><p>The logical nature of document spanners does not preclude the potential of utilizing generic solutions for Natural Language Processing (NLP) that are nowadays dominated by statistical and numerical analysis, from basic classifiers to Large Language Models.</p><p>Extensions such as Spannerlog showed how the theoretical framework can be elegantly combined with custom code as special user-defined functions called IE functions.</p><p>In this demonstration, we showcase SpannerLib: a library for integrating document spanners in Python, resulting in an IE development that enjoys the benefits of the imperative paradigm (arbitrary Python code, including calling ML models) and the declarative one (Datalog), thereby making rule-based IE development accessible to a wider developer audience.</p><p>We describe three pillars of our system: a full-fledged implementation of Spannerlog, an extension of Python with embedded Spannerlog via IPython’s Magic system, where the two types of code communicate via Pandas DataFrames, and a framework for constructing and registering IE functions to invoke Python code from within Spannerlog rules, which now serve as callback functions.</p><p>SpannerLib is a library for expressing document spanners.</p><p>In particular, it provides a concrete implementation of Spannerlog, which is a variant of Datalog that operates on strings and spans in addition to ordinary relational data.</p><p>By a schema we mean here a sequence of types, where each type is either “str” (string) or “span.”</p><p>An IE function is a stateless function that takes a tuple over a fixed schema and returns a relation over a fixed schema derived from the input.</p><p>For example, a standard NLP tool like part-of-speech tagging can be associated with an IE function that takes a string as input and returns word spans and corresponding tags.</p><p>IE functions that are widely studied in this context are regular expressions.</p><p>Assume a relational database schema.</p><p>A Datalog program is a collection of rules where predicate symbols are applied to variables or constants and can be recursive.</p><p>Spannerlog is essentially Datalog over relations on strings and spans, extended with IE clauses that refer to an execution of an IE function as a means of deriving facts using rules.</p><p>More precisely, an IE predicate binds all facts that can be derived from an application of the IE function over the values bound to its input variables.</p><p>A Spannerlog program is a set of Spannerlog rules, where a Spannerlog rule is defined similarly to a Datalog rule, except that rule bodies can include IE atoms.</p><p>This extension of Datalog rules allows us to elegantly compose multiple IE functions as part of a rule in a readable way.</p><p>The bedrock of SpannerLib is a Python implementation of the Spannerlog language which allows us to programmatically invoke the Spannerlog runtime from Python, and vice versa.</p><p>To build our Spannerlog implementation, we extended the naive bottom-up evaluation method to include evaluation of IE clauses.</p><p>Since Spannerlog requires a more intricate definition of rule safety, which in turn determines IE function execution order within a rule, we also implemented a semantic safety checker according to the safety definitions.</p><p>Additionally, we added aggregation functions to SpannerLib, and we will later illustrate their importance.</p><p>Note that the syntax and semantics are similar to previous Datalog formalisms for aggregation.</p><p>To be useful in the setting of a Python program, we embedded our Spannerlog engine inside the Python runtime, via IPython’s Magic system.</p><p>The Magic system allows us to write and register Spannerlog rules directly inside a Jupyter Notebook Cell.</p><p>SpannerLib uses markers to separate between Python code and Spannerlog rules.</p><p>The session object facilitates communication between the Python and Spannerlog runtimes.</p><p>This code constructs the input relation by taking a DataFrame and importing it to our engine, applies the Spannerlog rule to construct the output relation, and then populates the output DataFrame by querying it.</p><p>SpannerLib enables the user to empower Spannerlog with user-defined functions and integrate them within as novel callbacks to IE functions.</p><p>Any stateless Python function can be added as an IE callback via the session object, as long as the function accepts a relation as input and returns a relation (or sequence of relations) as output.</p><p>We first illustrate how SpannerLib can help build LLM pipelines by concisely expressing programmer intent and, in particular, avoiding orchestration boilerplate and data management.</p><p>Consider the task of developing a code completion program focused on suggesting documentation for the function currently containing the user cursor in a code editor.</p><p>One of the challenges of performing code completions is that the entire code base is too big to fit into the context window.</p><p>Copilot’s approach is to take the last files that were accessed in the code editor and feed them all as context to the LLM model.</p><p>This approach has two main weaknesses: there would mostly be a lot of irrelevant context in some of these files, and there could be very relevant instances of interacting with the function among the files that have not been touched recently.</p><p>We would like to provide the LLM with the following context: the code of the current function, and the code of all functions that call the current function.</p><p>This task requires integration of basic LLM core functionalities, can leverage basic human understanding of the text, and is unique in the orchestration of the specific solution while using very similar tooling as other solutions in the same field.</p><p>Using these generic primitives, it is quite simple and elegant to convey our pipeline’s logic via SpannerLib.</p><p>To study the ability of SpannerLib to simplify text analysis tasks on a bigger scale, we took the source code for an existing rule-based NLP pipeline and rewrote it with SpannerLib.</p><p>The original pipeline deals with analyzing medical text documents to classify patients based on their COVID-19 risk.</p><p>The pipeline consists of 4335 lines of Python code and is based on the open-source NLP library spaCy.</p><p>Over 90 percent of the code was either data management or pipeline orchestration.</p><p>Hence, we were able to reduce around 4000 lines of code into fewer than 400 lines of either Spannerlog rules or tabular data.</p><p>All demonstration scenarios are interactive Jupyter notebooks that contain step-by-step walkthroughs of how to design and implement increasingly complex programs using SpannerLib.</p>
    <h2>Original Abstract</h2> 
    <p>Document spanners have been proposed as a formal framework for declarative Information Extraction (IE) from text, following IE products from the industry and academia. Over the past decade, the framework has been studied thoroughly in terms of expressive power, complexity, and the ability to naturally combine text analysis with relational querying. This demonstration presents SpannerLib—a library for embedding document spanners in Python code. SpannerLib facilitates the development of IE programs by providing an implementation of Spannerlog (Datalog-based document spanners) that interacts with the Python code in two directions: rules can be embedded inside Python, and they can invoke custom Python code (e.g., calls to ML-based NLP models) via user-defined functions. The demonstration scenarios showcase IE programs, with increasing levels of complexity, within Jupyter Notebook.</p>
</body>
</html>
