<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excerpt</title>
</head>
<body>
    <h2>Excerpt</h2>
    <p>As the memory size of modern servers increasingly outpaces the TLB capacity, more TLB misses occur when running large-memory workloads, or when a process/thread migrates between NUMA nodes.</p><p>A TLB miss triggers a high overhead page-table walk.</p><p>If the page-table is in remote memory, the overhead is even higher, which we call page-table caused NUMA effect.</p><p>To mitigate the page-table caused NUMA effect, recent studies proposed page-table self-replication (PTSR).</p><p>The key idea is to replicate the page-tables of an application and make each NUMA node have the same replica.</p><p>Such PTSR is transparent to applications, indicating that PTSR can be enabled for an application without modifying it.</p><p>However, current PTSR techniques including Mitosis and vMitosis all involve manual decision.</p><p>Mitosis depends on users to manually enable PTSR in a system-wide or per-process manner.</p><p>It is extremely difficult for users to make such a decision because whether PTSR increases or decreases performance of an application depends on the application’s characteristics and the co-located applications.</p><p>To tackle this issue, we firstly carefully characterize the performance behavior of PTSR on different applications.</p><p>Subsequently, we identify three indicators including memory access rate (MAR), DTLB miss rate, and page-table access latency (PTL) for PTSR automation.</p><p>Finally, we design a hierarchical as well as gradual mechanism to leverage the three indicators to automatically enable/disable PTSR for an application to improve performance.</p><p>We call the proposed approach WASP.</p><p>WASP may make an application access remote page-tables when PTSR is enabled, as long as the latency is the shortest.</p><p>This is beneficial for an application’s performance when the application and other co-located ones contend for the local memory controller.</p><p>We devise a hierarchical as well as gradual mechanism based on the indicators to automatically enable/disable PTSR to reduce the page-table caused NUMA effect.</p><p>We evaluate WASP on x86 and ARM servers using 11 large-memory workloads.</p><p>The results show that WASP can achieve at least the same performance improvement as that obtained by manually enabling PTSR.</p><p>Paging is the current de facto standard for implementing virtual memory and page-tables are used to translate virtual addresses (VA) into physical addresses (PA).</p><p>To translate a memory address, the hardware walks over each level of the tree sequentially.</p><p>In virtualized environment, the number of memory accesses can be as large as 24 for an address translation.</p><p>On a NUMA architecture, page-tables of an application may locate at the memory of different NUMA nodes because of different memory allocation policies and thread migration made by OS.</p><p>Page-tables can be evenly distributed to all NUMA node memories with the interleave policy.</p><p>In such migration, the data pages also migrate with the help of AutoNUMA to the target node but its page-tables do not, making local page tables become remote ones.</p><p>Remote page table accessing is inevitable, degrading performance.</p><p>We employ the application GUPS to conduct experiments on Kunpeng 920 to compare its performance with and without PTSR enabled.</p><p>The performance of GUPS with RPI-LD is significantly lower (6.69×) than baseline.</p><p>When PTSR is enabled, the performance of GUPS with RPI-LD can be significantly improved, and is extremely close to the baseline.</p><p>This implies that PTSR can almost remove the page-table caused NUMA effect.</p><p>However, our experiments show that enabling PTSR may also significantly hurt performance in other cases.</p><p>This experiment demonstrates that system-wide PTSR can not remove the page-table caused NUMA effect in all cases.</p><p>The per-process PTSR is preferred.</p><p>However, it depends on an application’s characteristics as well as the complex co-location situation, which is hard for an end user to know.</p><p>Automatically enabling or disabling PTSR for a process is therefore desired, which motivates this work.</p><p>WASP may access the local or remote page-table replica depending on latency.</p><p>We propose three indicators to enable/disable PTSR: memory access rate (MAR), DTLB miss rate, and page-table access latency (PTL).</p><p>These indicators are easily available as well as lightweight on most processor architectures such as x86_64 and ARM64.</p><p>We devise a hierarchical as well as gradual mechanism to automatically enable PTSR for an application to improve performance.</p><p>At Step1, WASP measures MAR and compares it with a threshold.</p><p>If MAR is less than or equal to the threshold, WASP disables PTSR.</p><p>If DTLB miss rate is larger than the threshold, WASP proceeds to enable PTSR.</p><p>If the local PTL is the shortest, WASP makes the application access the local page-table replica.</p><p>Otherwise, it accesses the remote replica that has the shortest latency.</p><p>WASP implementation on x86_64 employs two performance counters, mem-loads and mem-stores, to calculate MAR.</p><p>For DTLB miss rate, we use four counters.</p><p>We now present how to apply WASP on an application running on a NUMA server.</p><p>WASP calls the system call “perf_event_open()” to measure performance events.</p><p>WASP then calls a newly developed syscall to enable PTSR if conditions are met.</p><p>WASP improves the overall performance of the workload.</p><p>The performance of applications with WASP is at least the same as that of them with manually enabled PTSR.</p><p>WASP does not degrade the performance of any application.</p><p>WASP can make the right decision for any application to guarantee non-performance-degradation.</p><p>WASP can help most users.</p><p>WASP can improve the performance of some applications compared to that of them with manually enabled PTSR.</p><p>For the first-touch policy, the geometric mean of the speedups brought by WASP over the manually enabled PTSR is 27%.</p><p>WASP still outperforms manual PTSR with large pages.</p><p>The geometric mean of speedups made by WASP over manual PTSR is 15%.</p><p>WASP always shows the same or better performance for the experimented applications with 4KB and 2MB pages.</p><p>This indicates WASP can also work well on x86 NUMA servers.</p><p>Compared to RPI-LD, WASP can improve the performance of GUPS by as high as 6.69×.</p><p>WASP can achieve the same performance as that obtained by the manual PTSR technique.</p><p>WASP successfully handles the local memory controller contention.</p><p>WASP can achieve higher performance than PTSR.</p><p>WASP can be at least used to improve the performance of AutoNUMA.</p><p>WASP does not cause high overheads for memory management operations in practice.</p><p>The general overhead of WASP comes from three parts.</p><p>WASP only adds 0.72% and 0.39% overheads for GUPS and Redis.</p><p>WASP can automatically improve the overall performance of popular data center applications by up to 1.36×.</p><p>WASP can improve the performance of workloads in multi-NUMA-node case by up to 1.82× and that in process migration case by up to 6.69×.</p>
    <h2>Original Abstract</h2> 
    <p>As modern servers scale their memory capacity, TLB misses have become increasingly frequent, especially in large-memory workloads and under thread migration across NUMA nodes. These misses incur high overhead due to remote page-table accesses—a phenomenon we term the page-table caused NUMA effect. While Page-Table Self-Replication (PTSR) mitigates this issue by replicating page-tables across nodes, existing solutions like Mitosis and vMitosis require manual configuration and can degrade performance when misapplied. To address this, we propose WASP, a lightweight, automatic mechanism that uses three hardware-accessible indicators—memory access rate (MAR), DTLB miss rate, and page-table access latency (PTL)—to dynamically enable or disable PTSR per application. WASP applies a hierarchical and gradual decision strategy to select the optimal replica (local or remote) based on latency, ensuring performance improvements even under memory controller contention. We evaluate WASP on x86 and ARM64 servers using 11 large-memory workloads and show that it achieves the same or better performance than manual PTSR, with up to 6.69× improvement and less than 1% overhead. WASP guarantees non-degradation, improves AutoNUMA behavior, and adapts effectively to complex co-location scenarios. Our results demonstrate that WASP is a practical, architecture-independent solution for managing page-table locality in NUMA systems.</p>
</body>
</html>
